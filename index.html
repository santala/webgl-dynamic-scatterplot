<!DOCTYPE html>

<html>
<head>
    <title>WebGL Dynamic Scatterplot</title>
    <link rel="stylesheet" href="style.css"/>
</head>
<body>

<img id="overlap" src="overlap.png" style="display: none"/>

<canvas id="canvas"></canvas>
<div id="uiContainer">
    <div id="ui">
        <label>Alpha&nbsp;<input id="alpha" type="range" min="0.01" value=".5" max="1.0" step=".01" /></label>
        <label>Marker&nbsp;size&nbsp;<input id="marker-size" type="range" min="1" value="10" max="100" step="1" /></label>
        <label>Color&nbsp;<input id="color" type="color" value="#8800ff" /></label>
    </div>
</div>

<!-- vertex shader -->
<script id="vertex-shader-2d" type="x-shader/x-vertex">
attribute vec2 a_position;
attribute vec2 a_texCoord;

uniform vec2 u_resolution;
uniform float u_flipY;

varying vec2 v_texCoord;

void main() {
   // convert the rectangle from pixels to 0.0 to 1.0
   vec2 zeroToOne = a_position / u_resolution;

   // convert from 0->1 to 0->2
   vec2 zeroToTwo = zeroToOne * 2.0;

   // convert from 0->2 to -1->+1 (clipspace)
   vec2 clipSpace = zeroToTwo - 1.0;

   //gl_Position = vec4(clipSpace * vec2(1, u_flipY), 0, 1);
   gl_Position = vec4(a_position, 0, 1);

   // pass the texCoord to the fragment shader
   // The GPU will interpolate this value between points.
   v_texCoord = a_texCoord;
}
</script>
<!-- fragment shader -->
<script id="fragment-shader-2d" type="x-shader/x-fragment">

    precision mediump float;
    precision mediump int;

    // our texture
    uniform sampler2D u_image;

    const int marker_w = 3;
    const int marker_len = marker_w * marker_w;

    uniform float u_marker[marker_len];

    uniform int u_stage;

    uniform vec2 u_srcSize;
    uniform vec2 u_dstSize;

    // the texCoords passed in from the vertex shader.
    varying vec2 v_texCoord;


    float channels_to_count(vec2 channels) {
        return (channels.x * 256. + channels.y) * 255.;
    }

    vec2 count_to_channels(float count) {
        return vec2(floor(count / 256.) / 255.,  mod(count, 256.) / 255.);
    }

    void main() {

        if (u_stage == 0) {
            // Downscale density map

            vec2 scale = u_srcSize / u_dstSize;
            vec2 srcPixelSize = 1. / u_srcSize;
            vec2 dstPixelSize = 1. / u_dstSize;

            float count = 0.;
            vec2 offset = vec2(0., 0.);

            ivec2 dstPixel = ivec2(v_texCoord * (u_dstSize - 1.));
            ivec2 srcPixelStart = ivec2(vec2(dstPixel) * scale);
            ivec2 srcPixelEnd = ivec2((vec2(dstPixel + 1) * scale));

            vec2 startF = vec2(srcPixelStart) / (u_srcSize - 1.);
            vec2 endF = vec2(srcPixelEnd) / (u_srcSize - 1.);

            vec2 startOffset = (vec2(dstPixel) / (u_dstSize - 1.)) - startF;
            vec2 endOffset = endF - (vec2(dstPixel + 1) / (u_dstSize - 1.));

            vec2 coord;
            vec4 dataSample;
            int x = srcPixelStart.x;
            int y = srcPixelStart.y;

            for (int i = 0; i < 9999; i++) {
                if (y > srcPixelEnd.y) {
                    break;
                }
                coord = (vec2(x, y) + .5) / (u_srcSize - 1.);
                dataSample = texture2D(u_image, coord);

                if (
                    (x > srcPixelStart.x || dataSample.x >= startOffset.x) &&
                    (y > srcPixelStart.y || dataSample.y >= startOffset.y) &&
                    (x < srcPixelEnd.x || dataSample.x < endOffset.x) &&
                    (y < srcPixelEnd.y || dataSample.y < endOffset.y)
                ) {
                    count += channels_to_count(dataSample.zw);
                    offset += dataSample.xy;
                }

                x++;
                if (x > srcPixelEnd.x) {
                    x = srcPixelStart.x;
                    y++;
                }
            }


            gl_FragColor = vec4(offset / count, count_to_channels(count));

        } else if (u_stage == 1) {
            // Apply marker

            vec2 dstPixelSize = 1. / u_dstSize;

            float count = 0.;

            int x = -marker_w / 2;
            int max_x = x + marker_w;
            int y = -marker_w / 2;

            for (int i = 0; i < marker_len; i++) {
                vec4 dataSample = texture2D(u_image, v_texCoord + dstPixelSize * vec2(x, y));
                count += u_marker[i] * channels_to_count(dataSample.zw);

                x++;
                if (x >= max_x) {
                    x -= marker_w;
                    y++;
                }
            }

            //gl_FragColor = vec4(texture2D(u_image, v_texCoord));
            gl_FragColor = vec4(0, 0, count_to_channels(count));
        } else if (u_stage == 2) {
            // Look up alpha
            vec4 dataSample = texture2D(u_image, v_texCoord);
            float overlap = channels_to_count(dataSample.zw);
            float alpha = .25;
            float opacity;
            if (overlap == 0.) {
                opacity = 0.;
            } else {
                opacity = 1. - pow(1. - alpha, overlap);
            }

            gl_FragColor = vec4(0, 0, 0, opacity);
        } else {
            // Unknown stage, return red.
            gl_FragColor = vec4(1, 0, 0, 1);
        }
    }
</script>

<script id="fragment-shader-2d-orig" type="x-shader/x-fragment">
    precision mediump float;

    // our texture
    uniform sampler2D u_image;
    uniform vec2 u_textureSize;
    uniform float u_kernel[9];
    uniform float u_kernelWeight;

    // the texCoords passed in from the vertex shader.
    varying vec2 v_texCoord;

    void main() {
        vec2 onePixel = vec2(1.0, 1.0) / u_textureSize;
        vec4 colorSum =
        texture2D(u_image, v_texCoord + onePixel * vec2(-1, -1)) * u_kernel[0] +
        texture2D(u_image, v_texCoord + onePixel * vec2(0, -1)) * u_kernel[1] +
        texture2D(u_image, v_texCoord + onePixel * vec2(1, -1)) * u_kernel[2] +
        texture2D(u_image, v_texCoord + onePixel * vec2(-1, 0)) * u_kernel[3] +
        texture2D(u_image, v_texCoord + onePixel * vec2(0, 0)) * u_kernel[4] +
        texture2D(u_image, v_texCoord + onePixel * vec2(1, 0)) * u_kernel[5] +
        texture2D(u_image, v_texCoord + onePixel * vec2(-1, 1)) * u_kernel[6] +
        texture2D(u_image, v_texCoord + onePixel * vec2(0, 1)) * u_kernel[7] +
        texture2D(u_image, v_texCoord + onePixel * vec2(1, 1)) * u_kernel[8];
        gl_FragColor = vec4(colorSum.rgb, 1);
    }
</script>

<script src="https://webglfundamentals.org/webgl/resources/jquery-1.7.1.min.js"></script>
<script src="https://webglfundamentals.org/webgl/resources/jquery.tablednd_0_5.js"></script>
<!--
for most samples webgl-utils only provides shader compiling/linking and
canvas resizing because why clutter the examples with code that's the same in every sample.
See https://webglfundamentals.org/webgl/lessons/webgl-boilerplate.html
and https://webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html
for webgl-utils, m3, m4, and webgl-lessons-ui.
-->
<script src="webgl-utils.js"></script>

<script src="script2.js"></script>

</body>
</html>

